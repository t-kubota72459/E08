# 順序回路 (シーケンス回路)

**ここで使っているシーケンスは、時間の流れ、時系列という意味で、シーケンス制御のシーケンスとはすこし意味が違う。シーケンス制御のシーケンスは「順番」の意味。**

さて、これまでで**組み合わせ回路**について勉強した。
NOT, AND, OR があればどんな回路でも作れる、ということを理解してもらえたと思う。
ただし、条件がひとつあった。それは「必ず入力で出力が決定する」ということである。

言い換えれば、**「計算（演算）」はするけど「記憶」はしない** 回路だった。

<br/>
<br/>
<div style="text-align: center;">
  <img src="./images/image40.png" width="70%">
  <br/>
</div>
<br/>

しかし、みなさんのスマートフォンを見てもわかるとおり、現在のコンピュータは、「以前の状態」を記憶していて、それによって動作が変わる部分もある。たとえば、TikTok のおすすめは、あなたの閲覧の履歴から好みの映像を流すようになっている。

これは入力だけでなく過去の履歴（記憶）が利用されている。

単純化すると下の図のように一つ前の状態によって動作が変わる、ということである。これを順序回路 (シーケンス回路) という。

「前の状態がこうだったから、今の値はこうしよう」

というように記憶が利用されている。

<br/>
<br/>
<div style="text-align: center;">
  <img src="./images/image33.png" width="50%">
  <br/>
  一つ前の出力が入力に回ってきて、次の出力に反映される
</div>

論理回路の状態を、**内部状態 (internal state)** という。現在の内部状態は、１回前の内部状態と現在の入力で決定する。

切符の自動販売機も、スマホも、高性能な大型コンピュータも、すべてこうしたシーケンス回路（順序回路）である。

# ラッチ

では一番簡単なメモリ（ラッチ）を紹介する。

- もし NOT2 の出力が 0 なら NOT1 の出力は 1
- もし NOT2 の出力が 1 なら NOT1 の出力は 0

どちらかの値を記憶している。

**最初の状態は未知、どちらになるかは予想できない** が、とにかく 1bit 記憶できる。

<br/>
<br/>
<div style="text-align: center;">
  <img src="./images/image41.png" width="80%">
  <br/>
</div>

**■ メタステーブル**   
電子回路において、本来規定されている時間よりも入力信号が変化した場合に、出力信号が安定しない状態。両方の NOT の出力が 0 と 1 の中間地点にある状態 (エラー状態)


## RS ラッチ

- NOR 回路の「タスキがけ」構造
- NOT のたすき掛けと似ているが、R と S を用いて記憶状態をコントールできる
- Q を**セット**したり**リセット**したりできるから SR ラッチ
- ラッチ (latch) は留め具を表す英単語

<br/>
<br/>
<div style="text-align: center;">
  <img src="./images/image42.png" width="60%">
  <br/>
</div>

### R=1, S=0

- NOR1 の一方 R=1 なので、Q=0, S=0 なので、~Q = 1

<br/>
<br/>
<div style="text-align: center;">
  <img src="./images/image46.png" width="60%">
  <br/>
</div>

### R=0, S=1

- NOR1 には 0 と ~Q が入力されるが、Q はわからない
- NOR2 には 1 が入力され、~Q は 0 になる
- NOR1  の入力が 00 となり、Q は 1 になる

<br/>
<br/>
<div style="text-align: center;">
  <img src="./images/image44.png" width="60%">
  <br/>
</div>


### R=1, S=1

- NOR1 と NOR2 に少なくともひとつ１の入力がある → Q, ~Q は0
<br/>
<br/>
<div style="text-align: center;">
  <img src="./images/image47.png" width="60%">
  <br/>
</div>

### R=0, S=0

- NOR1 には 0 と ~Q が入力、~Q はわからない
- NOR2 には 0 と Q が入力、Q はわからない

■ 前の Q, ~Q が決まっていれば決まる：
- 前の Q が 1 のとき、前の状態を維持する
- 前の Q が 0 のとき、前の状態を維持する

<br/>
<br/>
<div style="text-align: center;">
  <img src="./images/image48.png" width="60%">
  <br/>
</div>

## RS ラッチのまとめ

- R と S が 0 のとき、前の値を保持している
- ~Q には Q の否定が保持されている  
  → 1 bit 記憶している
- S は「セット」、R は「リセット」
- S=1, R=1 とすると、セットとリセットを同時にすることになり、意味をなさなくなってしまう（おかしな動作になる）

<br/>
<br/>
<div style="text-align: center;">
  <img src="./images/image49.png" width="60%">
  <br/>
</div>

<br/>
<br/>
<div style="text-align: center;">
  <img src="./images/image50.png" width="30%"><br/>
  <strong>RS ラッチの回路記号</strong>
  <br/>
</div>

## D ラッチ

RS は S と R 両方を ON にするとご動作を引き起こす。この問題を解消したのが **D ラッチ** である。

- CLK  
  クロックの略で、「いつ状態を変えるのか」をコントロールする
- D  
  データの略で「記憶させたいデータ」を入力する
  
<br/>
<br/>
<div style="text-align: center;">
  <img src="./images/image51.png" width="60%"><br/>
  <strong>D ラッチ</strong>
  <br/>
</div>

## D フリップフロップ

- D ラッチは CLK=1 のあいだ、いつでも値が変化する (D の値が取り込まれる)
- これでは具合が悪く、ある瞬間 (具体的には CLK の立ち上がり) のときだけ、値が更新されるほうが便利な時がある  
(専門用語で「クロックの立ち上がり」という)

これを実現したのが、D フリップフロップ (D-FF)

